#!/usr/bin/ruby1.9.1
# -*- coding: utf-8 -*-
#
# TwiProwl - Twitter Notification Script with Prowl.
# Version: 1.0
#
# Copyright (c) 2009,2010 Takuo Kitame.
#
# You can redistribute it and/or modify it under the same term as Ruby.
#

$:.unshift File.dirname(__FILE__)

require 'optparse'
require 'net/https'
require 'json'
require 'uri'
require 'yaml'
require 'logger'
require 'oauth'
require 'pstore'

STDOUT.sync = STDERR.sync = true

TWIPROWL_VERSION = "1.0.0"
$0 = "TwiProwl/#{TWIPROWL_VERSION}"

# define Process.daemon (ruby 1.9 feature)
unless Process.respond_to?(:daemon)
  def Process.daemon(nochdir = nil, noclose = nil)
    exit!(0) if fork
    Process.setsid
    Dir.chdir('/') unless nochdir
    unless noclose
      STDIN.reopen('/dev/null')  unless STDIN.closed?
      STDOUT.reopen('/dev/null') unless STDOUT.closed?
      STDERR.reopen('/dev/null') unless STDERR.closed?
    end
    0
  end
end

module Net
  class HTTPResponse
    def each_line( rs = "\n" )
      stream_check
      while line = @socket.readuntil( rs )
        yield line
      end
      self
    end
  end
end

# oAuth fix for >= 1.9.0
if RUBY_VERSION >= "1.9.0"
  module HMAC
    class Base
      def set_key(key)
        key = @algorithm.digest(key) if key.size > @block_size
        key_xor_ipad = Array.new(@block_size, 0x36)
        key_xor_opad = Array.new(@block_size, 0x5c)
        key.bytes.each_with_index do |value, index|
          key_xor_ipad[index] ^= value
          key_xor_opad[index] ^= value
        end
        @key_xor_ipad = key_xor_ipad.pack('c*')
        @key_xor_opad = key_xor_opad.pack('c*')
        @md = @algorithm.new
        @initialized = true
      end
    end
  end
end

module Net
  class HTTPResponse
    def each_line( rs = "\n" )
      stream_check
      while line = @socket.readuntil( rs )
        yield line
      end
      self
    end
  end
end

class TwiProwl
  API_BASE = "https://api.twitter.com/1/"
  LOGFILE = "twiprowl.log"
  PROWL_API_ADD = "https://prowl.weks.net/publicapi/add"
  MENTIONS = "#{API_BASE}statuses/mentions.json?"
  DIRECT_MESSAGES = "#{API_BASE}direct_messages.json?"
  RETWEETS = "#{API_BASE}statuses/retweets_of_me.json?"
  MEMBERSHIP = "#{API_BASE}lists/memberships.json?screen_name=%s&cursor=%d"
  FOLLOWERS  = "#{API_BASE}followers/ids.json?screen_name=%s&cursor=%d"
  USER_SHOW  = "#{API_BASE}users/show/%s.json"
  RATE_LIMIT = "#{API_BASE}account/rate_limit_status.json"
  STREAM_URL = "https://betastream.twitter.com/2b/user.json"

  CONSUMER_KEY = 'nqjjOwQ207D1r3sPVgRhA'
  CONSUMER_SECRET = 'Al0rV0Ud4zskHXZLfoEecPNj18Rk0faOrbpcojDOtM'
  ACCESS_SITE = 'https://api.twitter.com'

  CheckInfo = Struct.new(:name, :last_id, :func, :count, :interval, :priority, :followers, :req_auth, :thread, :time, :enable)

  attr_accessor :thread

  def initialize( global, config )
    @@conf = global
    _prowl_conf_validate( @@conf['Prowl'] )
    @mentions = CheckInfo.new( "Mentions", -1, "check_mentions" )
    @direct   = CheckInfo.new( "Direct", -1, "check_direct" )
    @retweets = CheckInfo.new( "Retweets", -1, "check_retweets" )
    @membership = CheckInfo.new( "Membership", -1, "check_membership" )
    @remotter = CheckInfo.new( "Remotter", -1, "check_followers" )
    @favorite = CheckInfo.new( "Favorite", -1, nil )

    @application = config['Application'] ? config['Application'] : "Twitter"

    @mentions.count = config['MentionsCount'] ? config['MentionsCount'] : 10
    @mentions.interval = config['MentionsInterval'] ? config['MentionsInterval'] : 300
    @mentions.priority = config['MentionsPriority'] ? config['MentionsPriority'] : 0
    @direct.count = config['DirectCount'] ? config['DirectCount'] : 10
    @direct.interval = config['DirectInterval'] ? config['DirectInterval'] : 600
    @direct.priority = config['DirectPriority'] ? config['DirectPriority'] : 0
    @retweets.count = config['RetweetsCount'] ? config['RetweetsCount'] : 10
    @retweets.interval = config['RetweetsInterval'] ? config['RetweetsInterval'] : 300
    @retweets.priority = config['RetweetsPriority'] ? config['RetweetsPriority'] : 0
    @membership.interval = config['MembershipInterval'] ? config['MembershipInterval'] : 300
    @membership.priority = config['MembershipPriority'] ? config['MembershipPriority'] : 0
    @membership.followers = Array.new
    @user = config['User']
    pass = config['Pass']
    @use_proxy = config['UseProxy']
    @threshold = config['RateLimitThreshold'] ? config['RateLimitThreshold'] : 20
    @remotter.interval = config['RemotterInterval'] ? config['RemotterInterval'] : 0
    @remotter.followers = Array.new
    @remotter.priority = config['RemotterPriority'] ? config['RemotterPriority'] : 0
    @remotter.req_auth = false
    @streaming = config['Streaming'] ? config['Streaming'] : false
    @favorite.enable   = config['Favorite'] ? config['Favorite'] : false
    @favorite.priority = config['FavoritePriority'] ? config['FavoritePriority'] : 0

    process_xauth( @user, pass )
    rate_limit_status( true )
  end

  @@conf = Hash.new
  @@logger = nil
  @@prowl_conf = nil

  private
  def process_xauth( user, pass )

    pdbfile = File.join( ENV['HOME'], ".twiprowl.pdb" )
    access_token = nil
    access_token_secret = nil

    if File.exist?( pdbfile )
      pdb = PStore.new( pdbfile )
      pdb.transaction do
        if pdb.root?( :tokens ) and pdb[ :tokens ][ user ]
          access_token = pdb[ :tokens ][ user ][ :access_token ]
          access_token_secret = pdb[ :tokens ][ user ][ :access_token_secret ]
        end
      end
    end

    params = {
     :site => ACCESS_SITE,
     :proxy => @use_proxy ? @@prowl_conf["ProxyURI"] : nil
    }

    @consumer = OAuth::Consumer.new( CONSUMER_KEY, CONSUMER_SECRET, params )
    begin
      if access_token && access_token_secret
        @access_token = OAuth::AccessToken.new(
          @consumer, access_token, access_token_secret
        )
        @token = OAuth::Token.new( access_token, access_token_secret )
      end
    rescue
       print "Failed to getting Access Token.\n"
       @access_token = nil
    end
    unless @access_token
      unless pass
        print "Failed to oAuth. Please add `Pass' into config file or...\n"
        print "Enter the password for #{user} now: "
        revertstty = `stty -g` rescue nil
        `stty -echo` rescue nil
        pass = gets.chomp.strip
        print "\n"
        `stty #{revertstty}` rescue nil
      end
      begin
        print "** Processing xAuth authorization for #{user}..."
        @access_token = @consumer.get_access_token(nil, {}, {
          :x_auth_mode => "client_auth",
          :x_auth_username => user,
          :x_auth_password => pass,
         })
        print " done.\n"
        pdb = PStore.new( pdbfile )
        pdb.transaction do
          pdb[ :tokens ] = Hash.new unless pdb.root?( :tokens )
          pdb[ :tokens ][ user ] = {
            :access_token => @access_token.token,
            :access_token_secret => @access_token.secret
          }
          pdb.commit
        end
        @token = OAuth::Token.new( @access_token.token, @access_token.secret )
        File.chmod( 0600, File.join( pdbfile ) )
      rescue OAuth::Unauthorized
        print "Failed to OAuth due to wrong password or the server error.\n"
        exit 1
      end
    end
    print "You can/should remove `Pass' for #{user} from config file.\n" if pass
  end

  def rate_limit_status( auth = false )
    json, res = get_json( RATE_LIMIT, auth )
    if res.code == "200"
      @rate = json['remaining_hits']
      @reset_at = Time.at( json['reset_time_in_seconds'] )
    end
  end

  def post_escape( string )
    string.gsub(/([^ a-zA-Z0-9_.-]+)/) do
      '%' + $1.unpack('H2' * $1.bytesize).join('%').upcase
    end.tr(' ', '+')
  end

  def _prowl_conf_validate(val)
    return if @@prowl_conf
    @@prowl_conf = val
    unless @@prowl_conf.kind_of?(Hash)
      STDERR.printf "Configuration Error: Prowl section must be Hash.\n"
      exit 1
    end
    unless @@prowl_conf.has_key?('APIKey')
      STDERR.printf "Configuration Error: APIKey must be given.\n"
      exit 1
    end
    if @@prowl_conf.has_key?('ProxyURL')
       @@prowl_conf['ProxyURI'] = URI::parse(@@prowl_conf['ProxyURL'])
    end
    _init_logger()
  end

  def _init_logger
    if @@conf['LogDir']
      logdir = @@conf['LogDir']
      Dir.mkdir(logdir) unless File.exist?(logdir)
      file = File.join(logdir, LOGFILE)
      STDOUT.print "All logs will be written into #{file}.\n"
      @@logger = Logger.new(file, 'daily')
      @@logger.level = @@conf['Debug'] ? Logger::DEBUG : Logger::INFO
      @@logger.datetime_format = "%Y-%m-%d %H:%M:%S"
    else
      @@logger = nil
    end
  end

  def _log( severity, str )
    if @@logger
      @@logger.add( severity, str, "#{@application}@#{@user}" )
    else
      format = "[%Y-%m-%d %H:%M:%S##{Process.pid}]" 
      if severity == Logger::ERROR
        STDERR.print Time.now.strftime( format ) + " #{@application}@#{@user} - #{str}\n"

      else
        print Time.now.strftime( format ) + " #{@application}:#{@user} - #{str}\n"
      end
    end
  end

  def get_json( url, auth = false )
    uri = URI::parse( url )
    debug "Check #{uri.request_uri}"
    begin
      if auth
        res = @access_token.get( url )
      else
        http = http_new( uri, @use_proxy )
        req = Net::HTTP::Get.new( uri.request_uri )
        res = http.request( req )
      end
      if res['X-RateLimit-Remaining']
        debug "RateLimit: %d/%d Reset at %s" % [
                                                 res['X-RateLimit-Remaining'],
                                                 res['X-RateLimit-Limit'],
                                                 Time.at(res['X-RateLimit-Reset'].to_i).strftime( "%Y-%m-%d %H:%M:%S" )
                                                ]
      end
    rescue
      error "HTTP Get Error: #{$!}"
      return [ nil, res ]
    end
    return res.code == "200" ? [ JSON::parse( res.body ), res ] : [ nil, res ]
  end

  def check_generic( reqstr, checkinfo )
    return unless rate_limit_check( @threshold )
    info "Checking: #{checkinfo.name}"

    if checkinfo.last_id > 0
      reqstr += "since_id=#{checkinfo.last_id}"
      reqstr += "&count=#{checkinfo.count}"
    else
      reqstr += "count=1"
    end

    json, res = get_json( reqstr, true )
    @rate = res['X-RateLimit-Remaining'].to_i
    @reset_at = Time.at(res['X-RateLimit-Reset'].to_i)
    return if json.nil?

    json.reverse.each do |obj|

      screen_name = obj.has_key?('sender_screen_name') ? obj['sender_screen_name'] : obj['user']['screen_name']
      event = "#{checkinfo.name}: #{screen_name}"

      desc = obj['text']
      desc.gsub!(/&(amp|quot|gt|lt);/u) do
        match = $1.dup
        case match
        when 'amp'  then '&'
        when 'quot' then '"'
        when 'gt'   then '>'
        when 'lt'   then '<'
        else
          "&#{match};"
        end
      end

      if checkinfo.last_id < 0
        debug "#{checkinfo.name}: initial last_id = #{obj['id']}"
      else
        debug "Prowling: %s %s" % [ event, desc ]
        prowl( :apikey => @@prowl_conf['APIKey'],
               :application=> @application,
               :event => event,
               :description => desc,
               :priority => checkinfo.priority
               )
        sleep 2
      end
      checkinfo.last_id = obj['id']
    end
    debug "#{checkinfo.name}: last_id = #{checkinfo.last_id}"
    return
  end

  # common 
  def check( checkinfo )
    return if checkinfo.interval == 0
    return if !checkinfo.time.nil? &&
               Time.now - checkinfo.time < checkinfo.interval
    checkinfo.time = Time.now
    checkinfo.thread = Thread.new do
      begin
        method( checkinfo.func ).call( checkinfo )
      rescue
        error "Error in #{checkinfo.name}: #{$!.to_s}"
        debug $!.backtrace.join("\n")
      end

      checkinfo.time = Time.now
      info "Done: #{checkinfo.name}"
      debug "#{checkinfo.name} sleep: #{checkinfo.interval} secs"
    end
  end

  # checking followers
  def check_followers( checkinfo )
    return unless rate_limit_check( @threshold )
    cursor = -1
    users = Array.new
    while cursor != 0
      info "Checking: Followers: cursor=#{cursor}"
      url = FOLLOWERS % [ @user, cursor ]
      json, res = get_json( url, checkinfo.req_auth )
      if res.code == "401"
        checkinfo.req_auth = true
        json, res = get_json( url, checkinfo.req_auth )
      end
      return if json.nil?
      cursor = json['next_cursor']
      users.concat( json['ids'].map{ |id| "#{id}" } ) # .map { |u| "@#{u['screen_name']}" } )
    end
    debug "Current followers: #{users.size}, Previous: #{checkinfo.followers.size}"
    if checkinfo.followers.size > 0
      diff = checkinfo.followers - users
      if diff.size > 0
        screen_names = Array.new
        diff.each do |id|
          url = USER_SHOW % [ id.to_s ]
          json, res = get_json( url )
          if json
            screen_names << "@#{json['screen_name']}"
          else
            screen_names << "ID:#{id}"
          end
        end
        if screen_names.size > 1
          b = screen_names.pop
          string = screen_names.join(", ")
          string += " and #{b}"
        else
          string = screen_names[0]
        end
        desc = string
        desc += (diff.size > 1 ? " have" : " has" ) + " unfollowed you..."
        prowl( :apikey => @@prowl_conf['APIKey'],
               :application=> @application,
               :event => "You've been unfollowed",
               :description => desc,
               :priority => checkinfo.priority
               )
      end
    end
    checkinfo.followers = users
  end

  # checking list membership
  def check_membership( checkinfo )
    return unless rate_limit_check( @threshold )
    cursor = -1
    lists = Array.new
    while cursor != 0
      info "Checking: Membership: cursor=#{cursor}"
      url = MEMBERSHIP % [ @user, cursor ]
      json, res = get_json( url, checkinfo.req_auth )
      if res.code == "401"
        checkinfo.req_auth = true
        json, res = get_json( url, checkinfo.req_auth )
      end
      return if json.nil?
      lists.concat( json['lists'].map{ |list| "#{list['full_name']}" } )
      cursor = json['next_cursor']
    end
    debug "Current memberships: #{lists.size}, Previous: #{checkinfo.followers.size}"
    if checkinfo.followers.size > 0
      diff = checkinfo.followers - lists
      if diff.size > 0
        if diff.size > 1
          b = diff.pop
          string = diff.join(", ")
          string += " and #{b}"
        else
          string = diff[0]
        end
        desc = "You have been removed from: " +  string
        prowl( :apikey => @@prowl_conf['APIKey'],
               :application=> @application,
               :event => "List membership",
               :description => desc,
               :priority => checkinfo.priority
               )
      end
      diff = lists - checkinfo.followers
      if diff.size > 0
        if diff.size > 1
          b = diff.pop
          string = diff.join(", ")
          string += " and #{b}"
        else
          string = diff[0]
        end
        desc = "You have been added to: " +  string
        prowl( :apikey => @@prowl_conf['APIKey'],
               :application=> @application,
               :event => "List membership",
               :description => desc,
               :priority => checkinfo.priority
               )
      end
    end
    checkinfo.followers = lists
  end

  # check Mentions
  def check_mentions( checkinfo )
    check_generic( MENTIONS, checkinfo )
  end

  # check Retweets
  def check_retweets( checkinfo )
    check_generic( RETWEETS, checkinfo )
  end

  # check DirectMessage
  def check_direct( checkinfo )
    check_generic( DIRECT_MESSAGES, checkinfo )
  end

  public
  def debug(str)
    _log(Logger::DEBUG, str)
  end

  def error(str)
    _log(Logger::ERROR, str)
  end

  def info(str)
    _log(Logger::INFO, str)
  end

  def http_new( uri, use_proxy = true )
    if @@prowl_conf['ProxyURI'] and use_proxy
      pu = @@prowl_conf['ProxyURI']
      http = Net::HTTP::Proxy( pu.host, pu.port, pu.user, pu.password ).new( uri.host, uri.port )
    else
      http = Net::HTTP.new( uri.host, uri.port )
    end
    if uri.scheme == "https"
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    end
    return http
  end

  def prowl( params={} )
    begin
      info "Prowling..."
      uri = URI::parse( PROWL_API_ADD )
      http = http_new( uri )
      request = Net::HTTP::Post.new( uri.request_uri )
      request.content_type = "application/x-www-form-urlencoded"
      query = params.map do |key, val| "#{key}=#{post_escape(val.to_s)}" end
      res = http.request( request, query.join( '&' ) )
      debug "Prowl Response: #{res.code}"
    rescue
      error "Error while Prowling: #{$!}"
    end
  end

  def rate_limit_check( threshold, auth = true )
    return true if threshold == 0
    debug "Current RateLimit Remaining: #{@rate}"
    return true if @rate > threshold
    rate_limit_status( auth )
    @rate > threshold
  end

  def unescape( text )
    text.gsub( /&(amp|quot|gt|lt);/u ) do
      match = $1.dup
      case match
      when 'amp'  then '&'
      when 'quot' then '"'
      when 'gt'   then '>'
      when 'lt'   then '<'
      else
        "&#{match};"
      end
    end unless text.nil? || text.empty?
  end

  def process_stream( json )
    mentions = json['entities'] ? json['entities']['user_mentions'] : nil
    retweets = json['retweeted_status']
    event    = json['event']
    if json['user']
      source = json['user']['screen_name']
    elsif json['source']
      source = json['source']['screen_name'] 
    else
      source = nil
    end
         
    desc = json['text']
    desc = unescape( desc )

    # RT event
    if retweets and retweets['user']['screen_name'] == @user
      event = "#{@retweets.name} by @#{source}" 
      debug "Prowling: %s %s" % [ event, desc ]
      prowl( :apikey => @@prowl_conf['APIKey'],
             :application=> @application,
             :event => event,
             :description => desc,
             :priority => @mentions.priority ) if @retweets.interval > 0
      return
    end


    # mentions event   
    if mentions and mentions.size > 0 and
      mentions.find do |m| m['screen_name'] == @user end
      event = "#{@mentions.name} from @#{source}"
      debug "Prowling: %s %s" % [ event, desc ]
      prowl( :apikey => @@prowl_conf['APIKey'],
             :application=> @application,
             :event => event,
             :description => desc,
             :priority => @mentions.priority ) if @mentions.interval > 0
      return
    end

    # Membership event
    case event
    when "list_member_added"
      desc = "You have been added into: #{json['target_object']['full_name']}" 
      prowl( :apikey => @@prowl_conf['APIKey'],
             :application=> @application,
             :event => "List membership",
             :description => desc,
             :priority => @membership.priority ) if @membership.interval > 0
    when "list_member_removed"
      desc = "You have been removed from: #{json['target_object']['full_name']}" 
      prowl( :apikey => @@prowl_conf['APIKey'],
             :application=> @application,
             :event => "List membership",
             :description => desc,
             :priority => @membership.priority ) if @membership.interval > 0
    when "favorite"
      target = json['target_object']['user']['screen_name']
      if target == @user and @favorite.enable
        text = json['target_object']['text']
        desc = unescape( text )
        prowl( :apikey => @@prowl_conf['APIKey'],
               :application=> @application,
               :event => "Favorite by @#{source}",
               :description => desc,
               :priority => @favorite.priority )
      end
    when "unfavorite"
      target = json['target_object']['user']['screen_name']
      if target == @user and @favorite.enable
        text = json['target_object']['text']
        desc = unescape( text )
        prowl( :apikey => @@prowl_conf['APIKey'],
               :application=> @application,
               :event => "Unfavorite by @#{source}",
               :description => desc,
               :priority => @favorite.priority )
      end
    else
      debug "Event: #{event}" unless event.nil? || event.empty?
    end          
  end

  def stream_check
    debug "Checking with Streaming API."
    uri = URI::parse( STREAM_URL )
    http = http_new( uri, @use_proxy )
    request = Net::HTTP::Post.new( uri.request_uri )
    request.set_form_data( { "replies" => "all" } )
    request.oauth!( http, @consumer, @token )
    begin
      http.request( request ) do |res|
        res.each_line( "\r\n" ) do |line|
          json = JSON::parse( line ) rescue next
          begin
            process_stream( json )
          rescue
            error( "BUG: error while process JSON" )
            error( $!.backtrace.join("\n") )
            error( $!.to_s )
          end
        end
      end
    ensure
      http.finish
    end
  end

  def run
    info "Starting thread for \"#{@application}\"."
    if @streaming
      thread = Thread.new do
        begin
          stream_check
        rescue
          error "Streaming Error: #{$!}"
          sleep 5
          retry
        end
      end
    end
    loop do
      check( @mentions ) unless @streaming
      check( @direct )
      check( @retweets ) unless @streaming
      check( @remotter )
      check( @membership ) unless @streaming
      sleep 1
    end # loop
  end
end

## __MAIN__

## command line options
ProgramConfig = Hash.new
opts = OptionParser.new
opts.on( "-c", "--config FILENAME", String, "Specify the config file." ) { |v| ProgramConfig[:config] = v }
opts.on( "-q", "--daemon",nil, "Enable daemon mode.") { |v| ProgramConfig[:daemon] = true }
opts.on( "-d", "--debug", nil, "Enable debug output." ) { |v| ProgramConfig[:debug] = true }
opts.version = TWIPROWL_VERSION
opts.program_name = "twiprowl"
opts.parse!( ARGV )

## config file
config_order = [
  File.join( ENV['HOME'], '.twiprowl.conf' ),
  File.join( Dir.pwd, 'twiprowl.conf' ),
  File.join( Dir.pwd, 'config.yml' ),
  File.join( File.dirname( __FILE__ ), 'twiprowl.conf' )
]

filename = nil
if ProgramConfig[:config]
  if File.exist?( ProgramConfig[:config] )
    filename = ProgramConfig[:config]
  else
    STDERR.print "Configuration file does not exist: #{ProgramConfig[:config]}\n"
    exit 1
  end
else
  config_order.each do |conf|
    next unless File.exist?( conf )
    filename = conf
    break
  end
end

if filename.nil?
  STDERR.print "No configuration file exist.\n"
  STDERR.print "File candidates are:\n"
  STDERR.print config_order.join("\n")
  STDERR.print "\n"
  exit 1
end

STDOUT.print "LoadConf: #{filename}\n" 
config = YAML.load_file( filename )
config["Debug"] = true if ProgramConfig[:debug]

accounts = Array.new
config['Accounts'].each do |account|
  ac = TwiProwl.new( config, account )
  accounts.push ac
end

## Daemon mode
if ProgramConfig[:daemon] || config['Daemon'] 
  begin
    Process.daemon( true, true )
  rescue
    STDERR.print $!
    exit 1
  end
  STDOUT.print "Daemonized. PID=#{Process.pid}\n"
end

Signal.trap(:INT) {
  exit
}
Signal.trap(:TERM) {
  exit
}

print "TwiProwl is running.\n"

accounts.each do |ac|
  ac.thread = Thread.new do
    ac.run
  end
end

# main loop thread
loop do
  sleep 60
  accounts.each do |ac|
    if ac.thread.nil? or !ac.thread.alive?
      ac.thread = Thread.new do
        ac.run
      end
    end
  end
end

# __END__
