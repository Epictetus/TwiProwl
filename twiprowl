#!/usr/bin/ruby
#
# TwiProwl - Twitter Notification Script with Prowl.
# Version: 0.1
#
# Copyright (c) 2009 Takuo Kitame.
#
# You can redistribute it and/or modify it under the same term as Ruby.
#
require 'net/https'
require 'json'
require 'uri'
require 'yaml'
require 'logger'

class TwiProwl
  
  PROWL_API_ADD = "https://prowl.weks.net/publicapi/add"
  MENTIONS = "https://twitter.com/statuses/mentions.json?"
  DIRECT_MESSAGES = "https://twitter.com/direct_messages.json?"

  def initialize(prowl_conf, config)
    @prowl_conf = prowl_conf
    @config = config
    @config['Application'] = "Twitter" unless @config.has_key?('Application')
    @config['MentionsCount'] = 10 unless @config.has_key?('MentionsCount')
    @config['MentionsInterval'] = 5 unless @config.has_key?('MentionsInterval')
    @config['DirectCount'] = 10 unless @config.has_key?('DirectCount')
    @config['DirectInterval'] = 10 unless @config.has_key?('DirectInterval')
  end

  def set_logger(logger)
    @logger = logger
  end

  def logger=val
    @logger=val
  end

  def debug(str)
    if @logger
      @logger.add(Logger::DEBUG, str, @config['Application'])
    else
      print Time.now.strftime("[%Y-%m-%d %H:%M:%S] DEBUG:"), 
      "#{@config['Application']} #{str}\n"
    end
  end

  def error(str)
    if @logger
      @logger.add(Logger::ERROR, str, @config['Application'])
    else
      print Time.now.strftime("[%Y-%m-%d %H:%M:%S] ERROR:"), 
      "#{@config['Application']} #{str}\n"
    end
  end

  def info(str)
    if @logger
      @logger.add(Logger::INFO, str, @config['Application'])
    else
      print Time.now.strftime("[%Y-%m-%d %H:%M:%S] INFO:"), 
      "#{@config['Application']} #{str}\n"
    end
  end

  def prowl(params={})
    u = URI::parse(PROWL_API_ADD)
    if @prowl_conf['ProxyHost']
      http = Net::HTTP::Proxy(@prowl_conf['ProxyHost'],
                              @prowl_conf['ProxyPort'],
                              @prowl_conf['ProxyUser'],
                              @prowl_conf['ProxyPass']).new(u.host, u.port)
    else
      http = Net::HTTP.new(u.host, u.port)
    end
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    request = Net::HTTP::Post.new(u.request_uri)
    query = params.map do |key, val| "#{key}=#{URI::encode(val)}" end
    return http.request(request, query.join('&'))
  end

  def check(reqstr, lastid, count)
    if lastid > 0
      reqstr += "since_id=#{lastid}"
      reqstr += "&count=#{count}"
    else
      reqstr += "count=1"
    end
    uri = URI.parse(reqstr)
    info "Checking... #{uri.path}"
    debug "Check #{uri.request_uri}"
    http = Net::HTTP::new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE 
    req = Net::HTTP::Get.new(uri.request_uri)
    req.basic_auth(@config['User'], @config['Pass'])
    res = http.request(req)
    if res.code == "200"
      json = JSON::parse(res.body)
      json.reverse.each do |obj|
        string = ""
        if obj.has_key?('sender_screen_name')
          string = "Direct: " + obj['sender_screen_name']
        else
          string = "Mentions: " + obj['user']['screen_name']
        end
        text = obj['text']
        if lastid < 0
          debug "last id = #{obj['id']}"
        else
          info "Prowling..."
          debug "Prowling: %s %s" % [ string, text ]
          prowl( :apikey => @prowl_conf['APIKey'],
                 :application=> @config['Application'],
                 :event => string,
                 :description => text )
          sleep 2
        end
        lastid = obj['id']
      end
    else
      debug "HTTP CODE: #{res.code}"
    end
    return lastid
  end

  def run
    info "Start"
    t1 = nil
    t2 = nil
    if @config['Mentions']
      t1 = Thread.new do
        last_id = -1
        loop do
          begin
            last_id = check(MENTIONS, last_id, @config['MentionsCount'])
            debug "Mentions last_id: #{last_id}"
          rescue
            error "MentionsError: " + $!.to_s
          end
          debug "Mentions sleep: #{@config['MentionsInterval']} mins"
          sleep @config['MentionsInterval'] * 60
        end
      end
    end
    if @config['Direct']
      t2 = Thread.new do 
        last_id = -1
        loop do
          begin
            last_id = check(DIRECT_MESSAGES, last_id, @config['DirectCount'])
            debug "Direct last_id: #{last_id}"
          rescue
            error "DirectError: " + $!.to_s
          end
          debug "Direct sleep: #{@config['DirectInterval']} mins"
          sleep @config['DirectInterval'] * 60
        end
      end
    end
  end

end

Dir.chdir(File.dirname(__FILE__))
config = YAML.load_file('config.yml')

# Logger
logdir = config['LogDir'] ? config['LogDir'] : nil
if logdir
  Dir.mkdir(logdir) unless File.exist?(logdir)
  STDOUT.print "All logs will be written into #{File.join(logdir, "imaprowl.log")}.\n"
  STDOUT.flush
  logger = Logger.new(File.join(logdir, "imaprowl.log"), 'daily')
  logger.level = config['Debug'] ? Logger::DEBUG : Logger::INFO
  logger.datetime_format = "%Y-%m-%d %H:%M:%S"
end

accounts = Array.new
config['Accounts'].each do |account|
  ac = TwiProwl.new(config['Prowl'], account)
  ac.logger = logger unless logger.nil?
  ac.run
end

loop do
  sleep 6000
end
