#!/usr/bin/ruby
#
# TwiProwl - Twitter Notification Script with Prowl.
# Version: 0.3
#
# Copyright (c) 2009 Takuo Kitame.
#
# You can redistribute it and/or modify it under the same term as Ruby.
#
require 'net/https'
require 'json'
require 'uri'
require 'yaml'
require 'logger'

class TwiProwl
  
  LOGFILE = "twiprowl.log"
  PROWL_API_ADD = "https://prowl.weks.net/publicapi/add"
  MENTIONS = "https://twitter.com/statuses/mentions.json?"
  DIRECT_MESSAGES = "https://twitter.com/direct_messages.json?"

  def initialize(global, config)
    @@conf = global
    _prowl_conf_validate(@@conf['Prowl'])
    @config = config
    @config['Application'] = "Twitter" unless @config.has_key?('Application')
    @config['MentionsCount'] = 10 unless @config.has_key?('MentionsCount')
    @config['MentionsInterval'] = 5 unless @config.has_key?('MentionsInterval')
    @config['MentionsPriority'] = 0 unless @config.has_key?('MentionsPriority')
    @config['DirectCount'] = 10 unless @config.has_key?('DirectCount')
    @config['DirectInterval'] = 10 unless @config.has_key?('DirectInterval')
    @config['DirectPriority'] = 0 unless @config.has_key?('DirectPriority')
  end

  @@conf = Hash.new
  @@logger = nil
  @@prowl_conf = nil

  private
  def _prowl_conf_validate(val)
    return if @@prowl_conf
    @@prowl_conf = val
    unless @@prowl_conf.kind_of?(Hash)
      STDERR.printf "Configuration Error: Prowl section must be Hash.\n"
      exit 1
    end
    unless @@prowl_conf.has_key?('APIKey')
      STDERR.printf "Configuration Error: APIKey must be given.\n"
      exit 1
    end
    _init_logger()
  end

  def _init_logger
    if @@conf['LogDir']
      logdir = @@conf['LogDir']
      Dir.mkdir(logdir) unless File.exist?(logdir)
      file = File.join(logdir, LOGFILE)
      STDOUT.puts "All logs will be written into #{file}."
      STDOUT.flush
      @@logger = Logger.new(file, 'daily')
      @@logger.level = @@conf['Debug'] ? Logger::DEBUG : Logger::INFO
      @@logger.datetime_format = "%Y-%m-%d %H:%M:%S"
    else
      @@logger = nil
      STDOUT.sync = true
    end
  end

  def _log(severity, str)
    if @@logger
      @@logger.add(severity, str, @application)
    else
      if severity == Logger::ERROR
        STDERR.print Time.now.strftime("[%Y.%m.%d %H:%M:%S] #{@application} - "), str, "\n"
      else
        print Time.now.strftime("[%Y.%m.%d %H:%M:%S] #{@application} - "), str, "\n"
      end
    end
  end

  public
  def debug(str)
    _log(Logger::DEBUG, str)
  end

  def error(str)
    _log(Logger::ERROR, str)
  end

  def info(str)
    _log(Logger::INFO, str)
  end

  def http_new(uri, use_proxy = true)
    if @@prowl_conf['ProxyHost'] and use_proxy
      http = Net::HTTP::Proxy(@@prowl_conf['ProxyHost'],
                              @@prowl_conf['ProxyPort'],
                              @@prowl_conf['ProxyUser'],
                              @@prowl_conf['ProxyPass']).new(uri.host, uri.port)
    else
      http = Net::HTTP.new(uri.host, uri.port)
    end
    return http
  end

  def prowl(params={})
    u = URI::parse(PROWL_API_ADD)
    http = http_new(u)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    request = Net::HTTP::Post.new(u.request_uri)
    query = params.map do |key, val| "#{key}=#{URI::encode(val.to_s)}" end
    debug "QueryString: " + query.join('&')
    return http.request(request, query.join('&'))
  end

  def check(reqstr, lastid, count, prio)
    if lastid > 0
      reqstr += "since_id=#{lastid}"
      reqstr += "&count=#{count}"
    else
      reqstr += "count=1"
    end
    uri = URI.parse(reqstr)
    info "Checking... #{uri.path}"
    debug "Check #{uri.request_uri}"
    http = http_new(uri, @config['UseProxy'])
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE 
    req = Net::HTTP::Get.new(uri.request_uri)
    req.basic_auth(@config['User'], @config['Pass'])
    res = http.request(req)
    if res.code == "200"
      json = JSON::parse(res.body)
      json.reverse.each do |obj|
        string = ""
        if obj.has_key?('sender_screen_name')
          string = "Direct: " + obj['sender_screen_name']
        else
          string = "Mentions: " + obj['user']['screen_name']
        end
        text = obj['text']
        if lastid < 0
          debug "last id = #{obj['id']}"
        else
          info "Prowling..."
          debug "Prowling: %s %s" % [ string, text ]
          res = prowl( :apikey => @@prowl_conf['APIKey'],
                       :application=> @config['Application'],
                       :event => string,
                       :description => text,
                       :priority => prio
                     )
          debug "Response: #{res}"
          sleep 2
        end
        lastid = obj['id']
      end
    else
      debug "HTTP CODE: #{res.code}"
    end
    return lastid
  end

  def run
    info "Start"
    t1 = nil
    t2 = nil
    if @config['Mentions']
      t1 = Thread.new do
        last_id = -1
        loop do
          begin
            last_id = check(MENTIONS, last_id,
                            @config['MentionsCount'], @config['MentionsPriority'])
            debug "Mentions last_id: #{last_id}"
          rescue
            error "MentionsError: " + $!.to_s
          end
          debug "Mentions sleep: #{@config['MentionsInterval']} mins"
          sleep @config['MentionsInterval'] * 60
        end
      end
    end
    if @config['Direct']
      t2 = Thread.new do 
        last_id = -1
        loop do
          begin
            last_id = check(DIRECT_MESSAGES, last_id,
                            @config['DirectCount'], @config['DirectPriority'])
            debug "Direct last_id: #{last_id}"
          rescue
            error "DirectError: " + $!.to_s
          end
          debug "Direct sleep: #{@config['DirectInterval']} mins"
          sleep @config['DirectInterval'] * 60
        end
      end
    end
  end

end

# __MAIN__

Dir.chdir(File.dirname(__FILE__))
config = YAML.load_file('config.yml')

accounts = Array.new
config['Accounts'].each do |account|
  ac = TwiProwl.new(config, account)
  ac.run
end

loop do
  sleep 6000
end

# __END__

