#!/usr/bin/ruby
#
# TwiProwl - Twitter Notification Script with Prowl.
# Version: 0.1
#
# Copyright (c) 2009 Takuo Kitame.
#
# You can redistribute it and/or modify it under the same term as Ruby.
#
require 'net/https'
require 'json'
require 'uri'
require 'yaml'

class TwiProwl
  
  PROWL_API_ADD = "https://prowl.weks.net/publicapi/add"
  MENTIONS = "https://twitter.com/statuses/mentions.json?"
  DIRECT_MESSAGES = "https://twitter.com/direct_messages.json?"

  def debug_puts(str)
    return unless @config['Debug']
    puts @config['Application'] + ": " + str
  end

  def initialize(prowl_conf, config)
    @prowl_conf = prowl_conf
    @config = config
    @config['Application'] = "Twitter" unless @config.has_key?('Application')
    @config['MentionsCount'] = 10 unless @config.has_key?('MentionsCount')
    @config['MentionsInterval'] = 5 unless @config.has_key?('MentionsInterval')
    @config['DirectCount'] = 10 unless @config.has_key?('DirectCount')
    @config['DirectInterval'] = 10 unless @config.has_key?('DirectInterval')
  end

  def prowl(params={})
    u = URI::parse(PROWL_API_ADD)
    if @prowl_conf['ProxyHost']
      http = Net::HTTP::Proxy(@prowl_conf['ProxyHost'],
                              @prowl_conf['ProxyPort'],
                              @prowl_conf['ProxyUser'],
                              @prowl_conf['ProxyPass']).new(u.host, u.port)
    else
      http = Net::HTTP.new(u.host, u.port)
    end
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    request = Net::HTTP::Post.new(u.request_uri)
    query = params.map do |key, val| "#{key}=#{URI::encode(val)}" end
    return http.request(request, query.join('&'))
  end

  def check(reqstr, lastid, count)
    if lastid > 0
      reqstr += "since_id=#{lastid}"
      reqstr += "&count=#{count}"
    else
      reqstr += "count=1"
    end
    debug_puts "Check #{reqstr}"
    uri = URI.parse(reqstr)
    http = Net::HTTP::new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE 
    req = Net::HTTP::Get.new(uri.request_uri)
    req.basic_auth(@config['User'], @config['Pass'])
    res = http.request(req)
    if res.code == "200"
      json = JSON::parse(res.body)
      json.reverse.each do |obj|
        string = ""
        if obj.has_key?('sender_screen_name')
          string = "Direct: " + obj['sender_screen_name']
        else
          string = "Mentions: " + obj['user']['screen_name']
        end
        text = obj['text']
        if lastid < 0
          debug_puts "last id = #{obj['id']}"
        else
          debug_puts "Prowling: %s %s" % [ string, text ]
          prowl( :apikey => @prowl_conf['APIKey'],
                 :application=> @config['Application'],
                 :event => string,
                 :description => text )
          sleep 2
        end
        lastid = obj['id']
      end
    else
      debug_puts "HTTP CODE: #{res.code}"
    end
    return lastid
  end

  def run
    debug_puts "Start"
    t1 = nil
    t2 = nil
    if @config['Mentions']
      t1 = Thread.new do
        last_id = -1
        loop do
          begin
            last_id = 
              check(MENTIONS, last_id, @config['MentionsCount'])
          rescue
            debug_puts "MentionsError: " + $!.to_s
          end
          debug_puts "Mentions sleep: #{@config['MentionsInterval']} mins"
          sleep @config['MentionsInterval'] * 60
        end
      end
    end
    if @config['Direct']
      t2 = Thread.new do 
        last_id = -1
        loop do
          begin
            last_id = check(DIRECT_MESSAGES, last_id, @config['DirectCount'])
          rescue
            debug_puts "DirectError: " + $!.to_s
          end
          debug_puts "Direct sleep: #{@config['DirectInterval']} mins"
          sleep @config['DirectInterval'] * 60
        end
      end
    end
  end

end

config = YAML.load_file('config.yml')
api_key = config['Prowl']['APIKey']
accounts = Array.new
config['Accounts'].each do |account|
  ac = TwiProwl.new(config['Prowl'], account)
  ac.run
end

loop do
  sleep 6000
end
