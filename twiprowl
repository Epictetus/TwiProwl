#!/usr/bin/ruby
# -*- coding: utf-8 -*-
#
# TwiProwl - Twitter Notification Script with Prowl.
# Version: 0.5
#
# Copyright (c) 2009,2010 Takuo Kitame.
#
# You can redistribute it and/or modify it under the same term as Ruby.
#

require 'optparse'
require 'net/https'
require 'json'
require 'uri'
require 'yaml'
require 'logger'

STDOUT.sync = STDERR.sync = true

TWIPROWL_VERSION = "0.5.0"
$0 = "TwiProwl/#{TWIPROWL_VERSION}"

# define Process.daemon (ruby 1.9 feature)
unless Process.respond_to?(:daemon)
  def Process.daemon(nochdir = nil, noclose = nil)
    exit!(0) if fork
    Process.setsid
    Dir.chdir('/') unless nochdir
    unless noclose
      STDIN.reopen('/dev/null')  unless STDIN.closed?
      STDOUT.reopen('/dev/null') unless STDOUT.closed?
      STDERR.reopen('/dev/null') unless STDERR.closed?
    end
    0
  end
end

class TwiProwl
  
  LOGFILE = "twiprowl.log"
  PROWL_API_ADD = "https://prowl.weks.net/publicapi/add"
  MENTIONS = "https://twitter.com/statuses/mentions.json?"
  DIRECT_MESSAGES = "https://twitter.com/direct_messages.json?"
  RATE_LIMIT = "https://twitter.com/account/rate_limit_status.json"
  FOLLOWERS  = "http://api.twitter.com/1/statuses/followers/%s.json"

  CheckInfo = Struct.new(:name, :last_id, :enable, :count, :interval, :priority, :followers, :thread)

  def initialize( global, config )
    @@conf = global
    _prowl_conf_validate( @@conf['Prowl'] )
    @mentions = CheckInfo.new( "Mentions", -1 )
    @direct   = CheckInfo.new( "Direct", -1 )
    @application = config['Application'] ? config['Application'] : "Twitter"

    @mentions.count = config['MentionsCount'] ? config['MentionsCount'] : 10
    @mentions.interval = config['MentionsInterval'] ? config['MentionsInterval'] : 300
    @mentions.priority = config['MentionsPriority'] ? config['MentionsPriority'] : 0
    @direct.count = config['DirectCount'] ? config['DirectCount'] : 10
    @direct.interval = config['DirectInterval'] ? config['DirectInterval'] : 600
    @direct.priority = config['DirectPriority'] ? config['DirectPriority'] : 0
    @user = config['User']
    @pass = config['Pass']
    @use_proxy = config['UseProxy']
    @threshold = config['RateLimitThreshold'] ? config['RateLimitThreshold'] : 20
    @remotter = CheckInfo.new( "Remotter" )
    @remotter.interval = config['RemotterInterval'] ? config['RemotterInterval'] : 0
    @remotter.followers = Array.new
    @remotter.priority = config['RemotterPriority'] ? config['RemotterPriority'] : 0
  end

  @@conf = Hash.new
  @@logger = nil
  @@prowl_conf = nil

  private
  def post_escape( string )
    string.gsub(/([^ a-zA-Z0-9_.-]+)/) do
      '%' + $1.unpack('H2' * $1.bytesize).join('%').upcase
    end.tr(' ', '+')
  end

  def _prowl_conf_validate(val)
    return if @@prowl_conf
    @@prowl_conf = val
    unless @@prowl_conf.kind_of?(Hash)
      STDERR.printf "Configuration Error: Prowl section must be Hash.\n"
      exit 1
    end
    unless @@prowl_conf.has_key?('APIKey')
      STDERR.printf "Configuration Error: APIKey must be given.\n"
      exit 1
    end
    _init_logger()
  end

  def _init_logger
    if @@conf['LogDir']
      logdir = @@conf['LogDir']
      Dir.mkdir(logdir) unless File.exist?(logdir)
      file = File.join(logdir, LOGFILE)
      STDOUT.print "All logs will be written into #{file}.\n"
      @@logger = Logger.new(file, 'daily')
      @@logger.level = @@conf['Debug'] ? Logger::DEBUG : Logger::INFO
      @@logger.datetime_format = "%Y-%m-%d %H:%M:%S"
    else
      @@logger = nil
    end
  end

  def _log( severity, str )
    if @@logger
      @@logger.add( severity, str, @application )
    else
      format = "[%Y-%m-%d %H:%M:%S##{Process.pid}] #{@application} - #{str}\n"
      if severity == Logger::ERROR
        STDERR.print Time.now.strftime( format )
      else
        print Time.now.strftime( format )
      end
    end
  end

  def check_followers( checkinfo )
    cursor = -1
    users = Array.new
    while cursor.to_i != 0
      uri = URI::parse( FOLLOWERS % [ @user ] + "?cursor=#{cursor}" )
      info "Checking Followers."
      debug " Check #{uri.request_uri}"
      http = http_new( uri, @use_proxy )
      req = Net::HTTP::Get.new( uri.request_uri )
      begin
        res = http.request( req )
        debug " RemotterRateLimit: %d/%d Reset at %s" % [
                                   res['X-RateLimit-Remaining'],
                                   res['X-RateLimit-Limit'],
                                   Time.at(res['X-RateLimit-Reset'].to_i).to_s
                                 ]
      rescue 
        error "HTTP Get Error: #{$!}"
        return false
      end
      json = JSON::parse( res.body )
      cursor = json['next_cursor'].to_i
      users.concat( json['users'].map { |u| "@#{u['screen_name']}" } )
    end
    debug "Current followers: #{users.size}, Previous: #{checkinfo.followers.size}"
    if checkinfo.followers.size > 0
      diff = checkinfo.followers - users
      if diff.size > 0
        desc = diff.join(", ")
        desc += ( diff.size > 1 ? " have" : " has" ) + " unfollowed you..."
        prowres = prowl( :apikey => @@prowl_conf['APIKey'],
                         :application=> @application,
                         :event => "You've been unfollowed",
                         :description => desc,
                         :priority => checkinfo.priority
                         )
        info "Prowling..."
        debug "Prowl Response: #{prowres.code}"
      end
    end
    checkinfo.followers = users
  end

  public
  def debug(str)
    _log(Logger::DEBUG, str)
  end

  def error(str)
    _log(Logger::ERROR, str)
  end

  def info(str)
    _log(Logger::INFO, str)
  end

  def http_new( uri, use_proxy = true )
    if @@prowl_conf['ProxyHost'] and use_proxy
      http = Net::HTTP::Proxy(@@prowl_conf['ProxyHost'],
                              @@prowl_conf['ProxyPort'],
                              @@prowl_conf['ProxyUser'],
                              @@prowl_conf['ProxyPass']).new( uri.host,
                                                              uri.port )
    else
      http = Net::HTTP.new( uri.host, uri.port )
    end
    return http
  end

  def prowl( params={} )
    begin
      uri = URI::parse( PROWL_API_ADD )
      http = http_new( uri )
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      request = Net::HTTP::Post.new( uri.request_uri )
      request.content_type = "application/x-www-form-urlencoded"
      query = params.map do |key, val| "#{key}=#{post_escape(val.to_s)}" end
      return http.request( request, query.join( '&' ) )
    rescue
      error "Error while Prowling: #{$!}"
      return nil
    end
  end

  def rate_limit_check( threshold )
    return true if threshold == 0
    uri = URI.parse( RATE_LIMIT )
    info "Checking Rate Limit Status."
    debug " Check #{uri.request_uri}"
    http = http_new( uri, @use_proxy )
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE 
    req = Net::HTTP::Get.new( uri.request_uri )
    req.basic_auth( @user, @pass )
    begin
      res = http.request( req )
    rescue 
      error "HTTP Get Error: #{$!}"
      return false
    end
    if res.code == "200"
      json = JSON::parse( res.body )
      limit = json['remaining_hits'].to_i
      debug " Remaining Hits: #{limit}"
      return ( limit >= threshold )
    else
      error " HTTP #{res}"
    end
    return false 
 end

  def check( reqstr, checkinfo )
    return unless rate_limit_check( @threshold )
    if checkinfo.last_id > 0
      reqstr += "since_id=#{checkinfo.last_id}"
      reqstr += "&count=#{checkinfo.count}"
    else
      reqstr += "count=1"
    end
    uri = URI.parse( reqstr )
    info "Checking: #{checkinfo.name}"
    debug " Check #{uri.request_uri}"
    http = http_new( uri, @use_proxy )
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE 
    req = Net::HTTP::Get.new( uri.request_uri )
    req.basic_auth( @user, @pass )
    begin
      res = http.request( req )
    rescue 
      error " HTTP Get Error: #{$!}"
      return
    end
    if res.code == "200"
      json = JSON::parse( res.body )
      json.reverse.each do |obj|
        if obj.has_key?('sender_screen_name')
          event = " Direct: " + obj['sender_screen_name']
        else
          event = " Mentions: " + obj['user']['screen_name']
        end
        desc = obj['text']
        desc.gsub!(/&(amp|quot|gt|lt);/n) do
          match = $1.dup
          case match
          when 'amp'  then '&'
          when 'quot' then '"'
          when 'gt'   then '>'
          when 'lt'   then '<'
          else
            "&#{match};"
          end
        end
        if checkinfo.last_id < 0
          debug " #{checkinfo.name}: last_id = #{obj['id']}"
        else
          info " Prowling..."
          debug "  Prowling: %s %s" % [ event, desc ]
          prowres = prowl( :apikey => @@prowl_conf['APIKey'],
                       :application=> @application,
                       :event => event,
                       :description => desc,
                       :priority => checkinfo.priority
                     )
          debug "Prowl Response: #{prowres.code}"
          sleep 2
        end
        checkinfo.last_id = obj['id']
      end
      
      debug " RateLimit: %d/%d Reset at %s" % [
                                              res['X-RateLimit-Remaining'],
                                              res['X-RateLimit-Limit'],
                                              Time.at(res['X-RateLimit-Reset'].to_i).to_s
                                             ]
    else
      debug " #{res}"
    end
    return
  end

  def run
    # remotter
    if @remotter.interval > 0 &&
        ( @remotter.thread.nil? || !@remotter.thread.alive? )
      @remotter.thread = Thread.new do
        loop do
          begin
            check_followers( @remotter )
          rescue
            error "RemotterError: #{$!.to_s}"
          end
          debug " Remotter sleep: #{@remotter.interval} secs"
          sleep @remotter.interval
        end
      end
    end
    # Mentions
    if @mentions.interval > 0 &&
        ( @mentions.thread.nil? || !@mentions.thread.alive? )
      info "Start thread for Mentions."
      @mentions.thread = Thread.new do
        loop do
          begin
            check( MENTIONS, @mentions )
            debug " Mentions last_id: #{@mentions.last_id}"
          rescue
            error " MentionsError: " + $!.to_s
          end
          debug " Mentions sleep: #{@mentions.interval} secs"
          sleep @mentions.interval
        end
      end
    end

    # DirectMessage
    if @direct.interval > 0 &&
        ( @direct.thread.nil? || !@direct.thread.alive? )
      info "Start thread for DirectMessage."
      @direct.thread = Thread.new do
        loop do
          begin
            check( DIRECT_MESSAGES, @direct )
            debug " Direct last_id: #{@direct.last_id}"
          rescue
            error " DirectError: " + $!.to_s
          end
          debug " Direct sleep: #{@direct.interval} secs"
          sleep @direct.interval
        end
      end
    end
  end

end

## __MAIN__

## command line options
ProgramConfig = Hash.new
opts = OptionParser.new
opts.on( "-c", "--config FILENAME", String, "Specify the config file." ) { |v| ProgramConfig[:config] = v }
opts.on( "-q", "--daemon",nil, "Enable daemon mode.") { |v| ProgramConfig[:daemon] = true }
opts.on( "-d", "--debug", nil, "Enable debug output." ) { |v| ProgramConfig[:debug] = true }
opts.version = TWIPROWL_VERSION
opts.program_name = "twiprowl"
opts.parse!( ARGV )

## config file
config_order = [
  File.join( ENV['HOME'], '.twiprowl.conf' ),
  File.join( Dir.pwd, 'twiprowl.conf' ),
  File.join( Dir.pwd, 'config.yml' ),
  File.join( File.dirname( __FILE__ ), 'twiprowl.conf' )
]

filename = nil
if ProgramConfig[:config]
  if File.exist?( ProgramConfig[:config] )
    filename = ProgramConfig[:config]
  else
    STDERR.print "Configuration file does not exist: #{ProgramConfig[:config]}\n"
    exit 1
  end
else
  config_order.each do |conf|
    next unless File.exist?( conf )
    filename = conf
    break
  end
end
if filename.nil?
  STDERR.print "No configuration file exist.\n"
  STDERR.print "File candidates are:\n"
  STDERR.print config_order.join("\n")
  STDERR.print "\n"
  exit 1
end

STDOUT.print "LoadConf: #{filename}\n" 
config = YAML.load_file( filename )
config["Debug"] = true if ProgramConfig[:debug]


## Daemon mode
if ProgramConfig[:daemon] || config['Daemon'] 
  begin
    Process.daemon( true, true )
  rescue
    STDERR.print $!
    exit 1
  end
  STDOUT.print "Daemonized. PID=#{Process.pid}\n"
end

accounts = Array.new
config['Accounts'].each do |account|
  ac = TwiProwl.new( config, account )
  ac.run
  accounts.push ac
end

Signal.trap(:INT) {
  exit
}
Signal.trap(:TERM) {
  exit
}

loop do
  sleep 60
  accounts.each do |ac|
    ac.run
  end
end

# __END__
